<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="marked.js"></script>
</head>

<body>
    <script>
        class Markdown {
            constructor({
                toRenderFunction,
                levelClass
            }) {

                // 默认情况下编译为模版
                this.toRenderFunction = toRenderFunction;

                // h标签的class
                this.levelClass = levelClass;
            }
        }

        class MarkAst {
            constructor(symbol, raw, text, closed) {
                this.symbol = symbol;
                this.children = [];
                this.tag = symbol2Tag[symbol];

                // 文本内容，仅纯文本具有该属性
                this.text = text;
                this.raw = raw;
                this.closed = closed;
                this.parent = null;
            }
        }

        let unicodeRegExp =
            /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/,
            asteriskRegExp = /\*{1,2}/,
            spSymbol = /`*/;

        // 匹配#标签，匹配到当前排的换行符之前 $1为# $2为匹配的文本
        const titleLevelRE = /^(\#{1,5})\s/,
            shortCodeRE = /^(`{1,2})/,

            // 匹配1~2个*，且它们后面不能跟空格否则无效
            asteriskRE = /^(\*{1,2})(?![\s\*])/,
            text = /^(.+?)(?![^`*\n])/,
            newline = /^(\n+)/;

        let symbol2Tag = {
            '#': 'h1',
            '##': 'h2',
            '###': 'h3',
            '####': 'h4',
            '#####': 'h5',
            '`': 'code',
            '``': 'code',
            'text': 'p'
        };

        function parseCotent(template) {
            let unhandleTemplate = template,
                index = 0,
                stack = [],
                lastAst = null;

            while (!!unhandleTemplate) {

                // 匹配#题目标签
                if (titleLevelRE.test(unhandleTemplate)) {

                    // 匹配到的对象
                    let titleMatch = unhandleTemplate.match(titleLevelRE);

                    // Match[1] 存放#，Match[0]存放#及其空格
                    updateLastAst(new MarkAst(titleMatch[1], titleMatch[0], null, true));

                    // 截取剩余的模版
                    advance(index, titleMatch[0].length);
                    continue;
                }

                // 处理``xx``或`xx`的短代码标签
                if (shortCodeRE.test(unhandleTemplate)) {
                    let shortCodeMatch = unhandleTemplate.match(shortCodeRE),

                        // 查询栈中是否存在匹配的标签
                        shouldCloseIndex = shouldCloseSymbol(shortCodeMatch[1]);

                    // 如果栈中有配对的标签，那么就闭合该标签，且将栈中该标签之后的未闭合标签视为普通字符串
                    if (shouldCloseIndex !== false) {

                        // 闭合标签
                        closeSymbol(shouldCloseIndex);
                    } else {

                        // 将该`推入栈中
                        updateLastAst(new MarkAst(shortCodeMatch[1], shortCodeMatch[0], null, false));
                    }

                    advance(index, shortCodeMatch[0].length);
                    continue;
                }

                // 匹配*语法
                if (asteriskRE.test(unhandleTemplate)) {
                    let asteriskMatch = unhandleTemplate.match(asteriskRE),
                        shouldCloseIndex = shouldCloseSymbol(asteriskMatch[1]);

                    // 遇到配对的标签时，就可以出栈了
                    if (shouldCloseIndex !== false) {

                        // 闭合标签
                        closeSymbol(shouldCloseIndex);
                    } else {
                        updateLastAst(new MarkAst(asteriskMatch[1], asteriskMatch[0], null, false));
                    }

                    advance(index, asteriskMatch[0].length);
                    continue;
                }

                // 如何截取文本？首先经过上面的排除，我们第一个字符肯定不为特殊符号。
                // 那么我们只需要找到后面第一个特殊符号位置停止即可。
                if (text.test(unhandleTemplate)) {
                    let textMatch = unhandleTemplate.match(text);

                    // 对于文本，我们直接将其存入当前栈顶标签对象的子节点数组中
                    setParent(new MarkAst('text', textMatch[0], textMatch[1], true), lastAst);

                    advance(index, textMatch[0].length);
                    continue;
                }

                // 处理换行符号，换行符可以闭合栈中任何未闭合的标签，换行符之间为一个段落
                if (newline.test(unhandleTemplate)) {

                    // 闭合栈中所有的未标签
                    closeSymbol();
                    advance(index, unhandleTemplate.match(newline)[1].length);
                }
            }


            // 更新模版，和当前在原始模版中的下标
            function advance(start, step) {

                // 更新当前模版在原模版中的下标b
                index = start + step;

                // 更新剩余要处理的模版
                unhandleTemplate = template.slice(index);
            }

            // 更新父级AST对象
            function updateLastAst(target) {

                // 未传入目标时，自动更新为当前栈的最后一个
                if (!target) return lastAst = stack[stack.length - 1];

                // 传入目标时，在栈中存放当前标签
                stack.push(target);

                // 将当前栈最顶层标签更新
                return lastAst = target;
            }

            // target加入parent的children数组中
            function setParent(target, parent) {
                parent.children.push(target);
            }

            // 查找stack是否有与其成对的标签，如果存在则说明应该闭合它
            function shouldCloseSymbol(symbol) {
                let times = stack.length;
                while (times--) {

                    if (stack[times].symbol === symbol) {
                        return times;
                    }
                }

                return false;
            }

            // `sada*as·da~sd`
            function closeSymbol(indexInStack) {

                // 获取当前要闭合的符号的ast对象
                let symbol = stack[indexInStack],
                    children = symbol.children;

                symbol.closed = true;

                children = flatChildren(children);

                // 遍历将其中所有未闭合的符号都转化为扁平的文本
                children = children.map(childAst => {

                    // 将未闭合的符号AST对象转化为文本
                    if (!childAst.closed) {
                        return new MarkAst('text', childAst.raw, childAst.symbol, true);
                    }

                    return childAst;
                });

                symbol.children = children;

                // 清除已闭合的符号
                stack.length = indexInStack;

                // 手动截断stack后，要更新lastAst
                symbol,updateLastAst();
            }
        }

        // 扁平化未闭合的符号
        function flatChildren(children) {

            let result = [];

            children.forEach(child => {

                // 找到子ast数组中未闭合的
                if (child.closed) {

                    // 闭合的直接返回
                    return result.push(child);

                    // 未闭合的标签将其当作文本，与其他闭合节点扁平化
                } else {
                    result = result.concat(child, ...flatChildren(child.children));
                }
            });

            return result;
        }

        parseCotent(`# 标题第二个文章
## asdas
\`sds\``);
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        const PENDING = 'pending';
        const RESOLVED = 'resolved';
        const REJECTED = 'rejected';
        const TYPE_MAP = {
            resolve: {
                type: 'resolve',
                handler: 'onFulfilled',
                status: RESOLVED
            },
            reject: {
                type: 'reject',
                handler: 'onRejected',
                status: REJECTED
            }
        };

        let activePromise = null;

        // 留着这方便调试
        let uuid = 0;

        function Promise1(executor) {
            if (typeof executor !== 'function') throw new Error('???');
            this.state = PENDING;
            this.value = void 0;
            this.thenExecutor = null;
            this.uuid = uuid++;

            // 存储一个当前正在处理的promise，如里面包含另一个promise，则不更新
            // 此时即使该promise处于reject，但未捕获也不报错
            if (activePromise === null) {
                activePromise = this;
            } else {
                this.isInternal = true;
            }
            try {
                executor(Promise1.resolve.bind(this), Promise1.reject.bind(this));

                // 发生错误时直接reject掉
            } catch (e) {
                Promise1.reject.call(this, e);
            }
        }

        Promise1.resolve = function (val) {
            let instance = this;

            // Promise初始化resolve后
            if (instance instanceof Promise1) {

                // ...调用回调
                return setTimeout(() => {

                    // 调用then
                    let thenExecutor = null;

                    // resolve了一个prmise时，要等到其传入的promise状态改变
                    if (val instanceof Promise1) {

                        // 将Promise最终的值用来继续启动任务
                        return val.then(handlerInstance.bind(null, instance, 'resolve'),
                            handlerInstance.bind(null, instance, 'reject'));
                    }

                    thenExecutor = instance.thenExecutor;
                    instance.state = RESOLVED;
                    instance.value = val;

                    if (!thenExecutor) {

                        // 这里要为最后一个then清空activePromise
                        return activePromise = null;
                    };

                    try {
                        thenExecutor.resolve(thenExecutor.onFulfilled(instance.value));
                    } catch (e) {
                        console.log(e);
                        // 这里先等等，我改
                        thenExecutor.reject(e);
                    }
                }, 0);
            }

            // 构造函数Promise.resolve API
            instance = new Promise1(resolve => {
                resolve(val);
            });

            return instance;
        }

        Promise1.reject = function (val) {
            let instance = this;

            // Promise初始化resolve后
            if (instance instanceof Promise1) {

                // ...调用回调
                return setTimeout(() => {

                    // 调用then
                    let thenExecutor = null;

                    // resolve了一个prmise时，要等到其传入的promise状态改变
                    if (val instanceof Promise1) {

                        // 将Promise最终的值用来继续启动当前promise的任务
                        return val.then(handlerInstance.bind(null, instance, 'resolve'),
                            handlerInstance.bind(null, instance, 'reject'));
                    }

                    thenExecutor = instance.thenExecutor;
                    instance.state = REJECTED;
                    instance.value = val;

                    // 这里只能return, 暂时无法判断Promise内部返回resolve一个promise的情况
                    if (!thenExecutor) {

                        // 如果是内部的未捕获的promise，则跳过
                        if (instance.isInternal) {
                            return;
                        }

                        // (外部)最后一个promise被rejcet且未捕获时报错
                        throw Error('Uncaught (???)  ' + instance.value);
                    };

                    try {

                        // 有捕获函数时，我们就要新的promise resolve掉
                        if (thenExecutor.onRejected) {
                            thenExecutor.resolve(thenExecutor.onRejected(instance.value));
                        } else {

                            // 没有设置catch类型的函数时，冒泡到下一个promise
                            thenExecutor.reject(instance.value);
                        }
                    } catch (e) {
                        debugger
                        console.log(e);
                        // 这里先等等，我改
                    }
                }, 0);
            }

            // 构造函数Promise.reject API
            instance = new Promise1((resolve, reject) => {
                reject(val);
            });

            return instance;


        };

        function handlerInstance(

            // 启动任务的promise
            instance,

            // 转换类型
            type,
            value
        ) {

            type = TYPE_MAP[type];
            instance.state = type.status;
            instance.value = value;

            // 这里要重新进行赋值，因为我们不清楚当前promise的下一个then
            // 方法何时会被调用，所以我们要在执行任务前重新确认一次
            let thenExecutor = instance.thenExecutor;

            // 只有在thenExecutor中，promise和then中的两个promise实例有交流的机会
            if (!thenExecutor) {

                // 如果是内部的未捕获的promise，则跳过
                if (instance.isInternal) {
                    return;
                }

                // (外部)最后一个promise被rejcet且未捕获时报错
                throw Error('Uncaught (???) ' + instance.value);
            };

            if (thenExecutor.onRejected) {
                thenExecutor[type.type](thenExecutor[type.handler](instance.value));
            } else {

                // 没有设置catch类型的函数时，冒泡到下一个promise
                thenExecutor[type.type](instance.value);
            }
        }
        Promise1.prototype.then = function (onFulfilled, onRejected) {

            activePromise = null;

            // 即调用该then方法的上一个Promise实例
            const prevInstance = this;

            // 完成状态的promise再次连接then时，需要我们手动启动任务
            if (prevInstance.state === RESOLVED) {
                return new Promise1(resolve => {
                    resolve(onFulfilled(prevInstance.value));
                });
            } else if (prevInstance.state === REJECTED) {
                return new Promise1((resolve, reject) => {

                    // 这里不一定有onRejected函数，所以我们要做判断
                    if (onRejected) {

                        // 如果注册了onRejected函数，那么成功处理后，我们将
                        // resolve当前的Promise实例
                        try {
                            resolve(onRejected(prevInstance.value));
                        } catch (e) {
                            reject(e);
                        }
                    } else {

                        // 若没有注册catch类型函数，那么我们让它冒泡到下一个promise
                        reject(prevInstance.value);
                    }
                });
            }

            const next = new Promise1((resolve, reject) => {

                // 此时该promise已执行，进入了pending状态
                prevInstance.thenExecutor = {
                    onFulfilled,
                    onRejected,
                    resolve,
                    reject
                };
            });

            return next;
        };

        Promise1.prototype.catch = function (onRejected) {
            return this.then((val) => {
                return val;
            }, onRejected);
        };
        // let vm = new Promise1(re => {
        //     setTimeout(() => {
        //         re(new Promise1(r => {
        //             setTimeout(() => {
        //                 r(5);
        //             }, 3000);
        //         }));
        //     }, 1000);
        // });
        // let vm1 = null;

        // setTimeout(() => {
        //     vm1 = vm.then((e) => {
        //         // throw Error(1)
        //         console.log(e);
        //         return 3;
        //     }).then((e) => {
        //         // throw Error(1)
        //         console.log(e);
        //         return 3;
        //     });
        // }, 2000);

        // Promise1.resolve(1).then((v) => {
        //     return new Promise1((r) => {
        //         setTimeout(() => {
        //             r(v);
        //         }, 1000);
        //     })
        // }).then(console.log);

        // promise生成顺序为：首先执行0，将生成1直接直接reject掉，此时无then，
        // 之后生成2、3，最后在0 resolve 阶段生成4。

        // 第一个re的是1，之后是0，然后是4

        // then的调用顺序为：首先为0的，然后2，最后为4的

        // 总体调用顺序为 0 - 1 - 4 - 2 - 3
        let vm3 = new Promise1((resolve, reject) => {

            // 1
            let vm1 = Promise1.reject(1);
            console.log(vm1)

            // 4
            resolve(vm1);
        });
        let vm5;

        let vm4 = vm3.then((v) => {

            // 2
            console.log(v);
        }).then((v) => {

            // 2
            console.log(v);
        }, (v) => {
            // 3

            vm5 = new Promise1((r, c) => {
                setTimeout(() => {
                    c(5);
                }, 1000)
            });
            console.log(vm5);
            return vm5.then((v) => {
                console.log(v);
            });
        });

        // let vm4 = vm3.then();
        console.log(vm4)
    </script>
</body>

</html>